<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><meta http-equiv="cache-control" content="no-cache" /><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 1. Plain old CLR objects</title><link rel="stylesheet" type="text/css" href="css/layout.css" /><link rel="stylesheet" type="text/css" href="css/screen.css" /><link rel="stylesheet" type="text/css" href="css/shCore.css" /><link rel="stylesheet" type="text/css" href="css/shCoreDefault.css" /><link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" /><link rel="stylesheet" type="text/css" href="css/documentation.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.0" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="next" href="bounded_roles.html" title="Chapter 2. Bounded Roles" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><script src="../script/shCore.js" type="text/javascript"></script><script src="../script/shBrushCSharp.js" type="text/javascript"></script><link rel="alternate" type="application/atom+xml" title="Development log" href="/atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </style>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--></head><body><div id="wrap"><div id="header"><a href="https://github.com/bards/Epic.NET"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><a class="title" href="/">Epic</a><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter"><div class="titlepage"><iframe src="http://www.ohloh.net/p/486199/widgets/project_users_logo.html" scrolling="no" style="height: 40px; width: 140px; border: none; float: right" frameBorder="0"></iframe><div><div><h2 class="title"><a id="poco"></a>Chapter 1. Plain old CLR objects</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="poco.html#about_fix_the_gap">Fix the gap</a></span></li><li><span class="section"><a href="poco.html#about_nothing_but_business_again">Nothing but business (again)</a></span></li><li><span class="section"><a href="poco.html#about_contracts_matter">Contracts matter</a></span></li><li><span class="section"><a href="poco.html#about_typed_explicitness">Typed explicitness</a></span></li></ul></div><p>Let’s be honest, object-oriented programming is not old in the .NET ecosystem.</p><p>When compared to the Java or C++ worlds, the penetration of design patterns
is quite recent, and the early adoption of service-oriented architectures
(showing a brute separation between data and behaviours) is symptomatic of the
tension between the complexities of object-orientated programming and the
widespread adoption that Microsoft achieves trying to lower the learning curve
required for their tools.</p><p>Moreover, the CLR was designed to support different programming languages and
paradigms, from Visual Basic to F#, to allow programmers getting the job done
fast whatever are their skills (or at least, make them believe to be fast).</p><p>Fortunatly, over the years, a number of very smart people have moved from
different platforms to .NET, borrowing previous experiences while creating
new idiomatic techniques.</p><p>When we choosed C# for the development of our new flagship product, we choosed
it among a set of languages and platforms that we knew quite well.
Its competitors were Java, C++, Python, Ruby and even more exotic ones.</p><p>In our analysis, C#/.NET was the best in very few sectors, but it won well to
the weighted sum of scores.</p><p>Indeed C# is a surprising (random?) mix of object-oriented and
functional features that fit very well our need when we develop complex
enterprise applications.</p><p>Linq and events are among our favourite features.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_fix_the_gap"></a>Fix the gap</h2></div></div></div><p>One of the bigger advantages of Java was the strong object-oriented community
it has. This is important when you know you’ll have to hire.</p><p>Nevertheless we already experienced how well-written documentation, good
teachers and pair programming can become powerful training tools,
and we decided to sistematically use them.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_nothing_but_business_again"></a>Nothing but business (again)</h2></div></div></div><p>The first thing we decided to teach to newcomers has been the POJO silver
bullet. <sup class="footnoteref">[<a name="id797325" href="#ftn.id797325" class="footnote" id="id797325">1</a>]</sup></p><p>We have a complex infrastructure that evolved over the years and often require
customization for each customer.
Instead, most business rules are the same all over the world (expecially in
financial markets).
We need to be able to replace the persistence framework without affecting
in any way on the domain model’s behaviour.</p><p>The only way to  achieve this is to express the company’s business in  C#
classes that have no connection with infrastructure choices.</p><p>Neither attributes nor base classes are allowed:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
you have to seal all classes that represent concrete concepts;
</li><li class="listitem">
you have name them after their business meaning;
</li><li class="listitem">
you have to fill them with relevant behaviours only;
</li><li class="listitem">
you have to keep them as simple as possible.
</li></ul></div><p>This way you’ll be able to replace the infrastructural code without wondering
if you are introducing bugs in the business.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_contracts_matter"></a>Contracts matter</h2></div></div></div><p>As you guessed, there is a trick. A simple one.</p><p>You have to define contracts for all entities and all domain services.
Everything outside the domain will depend on such interfaces. When needed,
the POCOs will be wrapped in autogenerated proxies that inject the required
infrastructure.</p><p>This could seem quite expensive at first, but since Epic makes everything
"domain dependent", such contracts provide many advantages during development:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
parallel development: when the model’s contracts are defined, everything that
  depends on them can begin its development cycle;
</li><li class="listitem">
quality assurance: everything that depends on contracts can be tested in
  isolation;
</li><li class="listitem">
decoupling: fixing bugs in the domain model will never require clients'
  recompilation (thus easing deploy too);
</li><li class="listitem">
easy injection and proxing (the Epic’s trick to conquer the world).
</li></ul></div><p>The development parallelization is so strong that it paid the investment alone.</p><p>However the flip side shows an increment in the efforts required for project
management (from 5 to 20 percent, following granularity of contexts).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_typed_explicitness"></a>Typed explicitness</h2></div></div></div><p>Make <span class="strong"><strong>everything explicit</strong></span>, avoid abstractions that domain experts ignore.</p><p>This has been the harder lesson we learnt.</p><p>We choose a strongly typed language to minimize the risk for implicitness.
Each useful concept should have its own type in the domain.
Bytes are cheaper than bugs.</p><p>A modeler should never abstract concepts on his own, his code should
solely express the expert’s vision. This is difficult to achieve for us, since
programmers are trained for abstract thinking, but all the abstractions
introduced without the explicit support of the domain expert led us to very
subtle and expensive bugs.</p><p>On the opposite, keeping the models down-to-earth and sticking to the target
business gave us good code that has been reused in different banks.</p><p>This could seem counterintuitive, but you should avoid patterns designed to
make your code maintainable or fast. Of course they are valuable per se,
but whenever you leave the ubiquitous language to introduce them, you
are always introducing long-term bugs.</p><p>Implicitness leads to a dangerous self-confidence: you think that everything
works as expected just becouse you are not looking at the full picture.
When new challenges arise, a fully explicit domain will evolve easily and
in a predictable amount of time.</p><p>While someone finds such approach a bit naive, it is a carefully analyzed
simplification that moves us back to the origin of object-orientated
programming. Indeed, while working on big corporate softwares, an easy and
fast comunication is more valuable that a reuse-oriented design.
Reuse will come after the use, when your code will have paid the bill for a
while.</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id797325" class="footnote"><p><sup class="footnote">[<a name="ftn.id797325" href="#id797325" class="simpara" id="ftn.id797325">1</a>] </sup>This is not a typo: the POJO term was coined for Java.
When it was ported to .NET it was a oxymoron.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="a_shared_modeling_grammar.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bounded_roles.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part I. Toward a shared modeling grammar </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Chapter 2. Bounded Roles</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2013 Giacomo Tesio</div></div><script type="text/javascript">SyntaxHighlighter.all()</script></body></html>
