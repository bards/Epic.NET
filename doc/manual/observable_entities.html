<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><meta http-equiv="cache-control" content="no-cache" /><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 5. Observable Entities</title><link rel="stylesheet" type="text/css" href="css/layout.css" /><link rel="stylesheet" type="text/css" href="css/screen.css" /><link rel="stylesheet" type="text/css" href="css/shCore.css" /><link rel="stylesheet" type="text/css" href="css/shCoreDefault.css" /><link rel="stylesheet" type="text/css" href="css/shThemeDefault.css" /><link rel="stylesheet" type="text/css" href="css/documentation.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.0" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="command_query_separation.html" title="Chapter 4. Command - Query separation" /><link rel="next" href="solid_principles.html" title="Chapter 6. SOLID Principles" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><script src="../script/shCore.js" type="text/javascript"></script><script src="../script/shBrushCSharp.js" type="text/javascript"></script><link rel="alternate" type="application/atom+xml" title="Development log" href="/atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </style>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--></head><body><div id="wrap"><div id="header"><a href="https://github.com/bards/Epic.NET"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><a class="title" href="/">Epic</a><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter"><div class="titlepage"><iframe src="http://www.ohloh.net/p/486199/widgets/project_users_logo.html" scrolling="no" style="height: 40px; width: 140px; border: none; float: right" frameBorder="0"></iframe><div><div><h2 class="title"><a id="observable_entities"></a>Chapter 5. Observable Entities</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="observable_entities.html#about_who_where_when_what_8230">Who, where, when, what…</a></span></li><li><span class="section"><a href="observable_entities.html#about_8230_and_why">…and why</a></span></li><li><span class="section"><a href="observable_entities.html#about_domain_events">Domain events</a></span></li><li><span class="section"><a href="observable_entities.html#about_did_you_feel_that_earthquake">Did you feel that earthquake?!</a></span></li></ul></div><p>One of the best feature that C# offers to modelers is the event pattern.<br />
In general, this pattern is expressed as formal naming conventions for
delegates, events, and related methods involved in the event notification
process. Thanks to this slight variation on the classical observer pattern,
.NET developers can easily decouple the subject and the observer.</p><p>This is not the medication for all ills, however: everybody knows the memory
leaks that forgotten delegates can cause.</p><p>Epic provides a set of tool to take full advantage of the smart pattern
proposed from Microsoft without the connected risks.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_who_where_when_what_8230"></a>Who, where, when, what…</h2></div></div></div><p>First of all, we noted that only the entities can be subject to observation,
as they own an identity.</p><p>The underlying rationale is that whenever an entity recieves a command, it
should inform the world about what happened.
This should not be a technicality, based on a naming convention connected to
the invoked command or related to the changed data.</p><p>The name of the event should be a verb in past tense that expresses <span class="strong"><strong>what</strong></span>
happened. The event <code class="literal">sender</code> will tell to the observer about who is the
protagonist of the news.
The custom EventArgs should describe the news itself, providing informations
useful to domain experts.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_8230_and_why"></a>…and why</h2></div></div></div><p>This simple set or rules produces a really powerfull tool, solving a number of
apparently unrelated problems such as GUI sincronization, persistence, logging,
high availability and so on.</p><p>For example, a presenter built with Epic.Poem can take advantage of the model’s
events to update the view, a repository can observe the entities to update the
db or to log something.
No more need for presentation models, data models and so on, with Epic
there’s no other model before the domain model.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_domain_events"></a>Domain events</h2></div></div></div><p>Back in the 2008, Udi Dahan introduced the concept of "Domain Events" that
rapidly became popular in the domain-driven comunity as Evans talked about them
in 2010.</p><p>Almost concurrently, we were developing our brand-new application,
based on the (at time evolving) patterns described here.
I remember quite well the discussions we had about the Dahan’s proposals.
I would like to say that we kept the previous approach due to design
considerations, but guess what? The decision was already taken due to the
advanced status of the project.</p><p>That being said, I prefer our previous approach. With my architect hat on, I
saw a major issue in Dahan’s method: <span class="strong"><strong>implicitness</strong></span>.</p><p>Only the code knows which events that an command can fire. You should read the
code of each entity to see which events you could subscribe.
You could add relevant events without changing the clients.
<sup class="footnoteref">[<a name="id798451" href="#ftn.id798451" class="footnote" id="id798451">4</a>]</sup></p><p>Even if we had had time to change the existing code base, I would had dislike
the choice. Indeed with Epic and the Observable Entities pattern you could get
all the advantages of the dispatching tecnique described, in a much more
explicit and natural way (since the .NET events can be exposed in the
contracts).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_did_you_feel_that_earthquake"></a>Did you feel that earthquake?!</h2></div></div></div><p>What if a relevant event do not belong to any known entity?</p><p>Although very uncommon, such circumstance exists.</p><p>The "Domain Events" pattern would handle the headless events as all others.</p><p>In the context of Epic, instead, you have to model them as events connected to
the one that percieve them: the user (playing a role). Indeed, each user has an
identity, and when he play a bounded role, he can percieve interesting events
from the outside world. We just transferred such simple observation into the
code (explicitly, in the contracts).</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id798451" class="footnote"><p><sup class="footnote">[<a name="ftn.id798451" href="#id798451" class="simpara" id="ftn.id798451">4</a>] </sup>If you maintained a complex corporate software for more than one
year and you aren’t paid by the hour, you know how such implicitness can
become a nightmare during deployments. <br />
There’s no denying that there is a profitable software business in
extraordinary repairs (even if due to bugs left behind).
However Epic is designed for high-quality software: if you need such kind of
long term revenues, you should avoid the complexity of its approach.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="command_query_separation.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="solid_principles.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. Command - Query separation </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Chapter 6. SOLID Principles</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2013 Giacomo Tesio</div></div><script type="text/javascript">SyntaxHighlighter.all()</script></body></html>
