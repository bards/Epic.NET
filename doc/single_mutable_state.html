<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="refresh" content="0;url=http://epic.tesio.it/doc/manual/single_mutable_state.html" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 8. Single Mutable State</title><link rel="stylesheet" href="/layout.css" type="text/css" /><link rel="stylesheet" href="/screen.css" type="text/css" /><link rel="stylesheet" href="css/shCore.css" type="text/css" /><link rel="stylesheet" href="css/shCoreDefault.css" type="text/css" /><link rel="stylesheet" href="css/shThemeDefault.css" type="text/css" /><link rel="stylesheet" href="css/documentation.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="repositories.html" title="Chapter 7. Repositories" /><link rel="next" href="the_bellis_perennis.html" title="Part II. The bellis perennis" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><script src="script/shCore.js" type="text/javascript"></script><script src="script/shBrushCSharp.js" type="text/javascript"></script><link rel="alternate" type="application/atom+xml" title="Development log" href="atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </xsl:element>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--></head><body><div id="wrap"><div id="header"><a href="http://github.com/Shamar/Epic.NET/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><a class="title" href="/">Epic</a><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter" title="Chapter 8. Single Mutable State"><div class="titlepage"><div><div><h2 class="title"><a id="single_mutable_state"></a>Chapter 8. Single Mutable State</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="single_mutable_state.html#about_intent">Intent</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_motivation">Motivation</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_applicability">Applicability</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_structure">Structure</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_participants">Participants</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_collaboration">Collaboration</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_consequences">Consequences</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_implementation">Implementation</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_sample_code">Sample Code</a></span></li><li><span class="section"><a href="single_mutable_state.html#about_related_patterns">Related Patterns</a></span></li></ul></div><p>The Single Mutable State is the only real design pattern that was designed
for the implementation of the domain model’s entities.
It’s optional, since the Epic infrastructure does not have any requirement in
the domain model implementation: you can use sealed classes without any
abstract base and without any attribute.
<sup>[<a id="id342916" href="#ftn.id342916" class="footnote">7</a>]</sup><br />
However we suggest it beyond the context it was designed for.</p><p>Indeed the Epic.Server system is based on the thread safety that this
pattern provide, to allow a easy to use, transparent and cheap CQRS system.
So, if you think that your entities will eventually need the features provided
from the pattern (or its useful side effects), you should consider to adopt it
massively on all entities that you implement.</p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>The Single Mutable State is a behavioral pattern, directly derived from
the GoF State Pattern. A plugin for your favorite IDE will be provided
soon to get rid of its verbosity and to enhance your productivity.</p></td></tr></table></div><div class="section" title="Intent"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_intent"></a>Intent</h2></div></div></div><p>Decouples state transitions from command invocation to enable concurrency and
simplify synchronized access to an <span class="strong"><strong>entity</strong></span> that <span class="strong"><strong>can</strong></span> reside in its
own thread of control. <sup>[<a id="id342964" href="#ftn.id342964" class="footnote">8</a>]</sup></p></div><div class="section" title="Motivation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_motivation"></a>Motivation</h2></div></div></div><p>A private banker and a customer share the access to an investment proposal by
distinct applications. The private banker modifies the proposal while he’s
talking to the customer via phone.
The customer can see the proposal’s evolution on his own terminal
(suppose an IPhone app) and he can accept the proposal by clicking a button.
Once the proposal has been accepted the advisor can not modify it further and
the his application moves to a new screen where he can send the orders to the
routing system of the bank.</p><p>To enforce the business rules, the different applications need a shared access
to the proposal (a well known entity in the context), but the different
instances need a realtime synchronization.
Moreover, the bank’s <span class="strong"><strong>lawyers prefer consistency</strong></span> to availability.</p><p>The key idea in this pattern is to implement the entity’s contract with a
class containing a single mutable field, the entity state. The entity delegates
<span class="strong"><strong>all</strong></span> requests (both queries and commands) to this state object. Such states
are immutable implementations of a common base class and rappresent the
different operational states; they provide explicit state transitions for the
commands in the contract.</p><p>For example the abstract <code class="literal">InvestmentProposalState</code>
replicates the contract of the related <code class="literal">InvestmentProposal</code>, but replaces
commands like <code class="literal">void Acquire(FundQuote)</code> with queries like
<code class="literal">InvestmentProposalState Acquire(FundQuote)</code> returning the new state that the
<code class="literal">InvestmentProposal</code> will have. The <code class="literal">InvestmentProposal</code> will works like a
proxy: it delegates to the current state all the recieved commands, it replaces
the previous mutable state with an atomic operation (a Compare And Swap
instruction) and it fires the relevant events.</p><p>This might seem complex (and it was, on the real world financial example
described before), however a simple use case is shown in the
<code class="literal">Cargo</code> / <code class="literal">CargoState</code> sample provided with Epic.</p></div><div class="section" title="Applicability"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_applicability"></a>Applicability</h2></div></div></div><p>Use the Single Mutable State pattern when you need a realtime synchronization
between different applications running the same bounded context.</p><p>The thread safe access provided will be easy to implement and it will leave your
entities simple, clean and indipendent from the infrastructure (as they only
depend on the CLR).</p></div><div class="section" title="Structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_structure"></a>Structure</h2></div></div></div><div class="informalfigure"><div class="mediaobject" align="center"><img src="images/sms_pattern.png" align="middle" alt="Single Mutable State structure" /></div></div></div><div class="section" title="Participants"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_participants"></a>Participants</h2></div></div></div><div class="variablelist"><dl><dt><span class="term">
Entity
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
implements the interface known to the clients
</li><li class="listitem">
maintains an instance of a ImmutableState subclass that defines the
      current state
</li><li class="listitem">
delegates all queries recieved to the current state
</li><li class="listitem">
delegates commands driven state transitions to the current state
</li><li class="listitem">
updates atomically the current state
</li></ul></div></dd><dt><span class="term">
Entity State
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
defines an interface for encapsulating the state transitions accociated
      with a particular sate of the Entity
</li><li class="listitem">
contains <span class="strong"><strong>readonly</strong></span> fields only
</li></ul></div></dd><dt><span class="term">
ImmutableState subclasses
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
each subclass implements the transitions allowed from the state it
      represents
</li><li class="listitem">
contains <span class="strong"><strong>readonly</strong></span> fields only
</li><li class="listitem">
does not reference any mutable object
</li></ul></div></dd></dl></div></div><div class="section" title="Collaboration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_collaboration"></a>Collaboration</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
The Entity delegates all request to the ImmutableState object.
</li><li class="listitem">
The Entity updates its own state atomically using a Compare &amp; Swap algoritm
</li><li class="listitem">
The Entity raises the relevant events when appropriate.
</li><li class="listitem">
Clients only know the Entity, and they don’t have to deal with its state
  directly.
</li><li class="listitem">
The concrete ImmutableStates decide which state succeeds another and under
  what circumstances.
</li></ul></div></div><div class="section" title="Consequences"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_consequences"></a>Consequences</h2></div></div></div><p>Like the classic State pattern, the Single Mutable State has the following
consequences:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
It localizes state specific behaviour and partitions behaviour for different
   states.
</li><li class="listitem">
It make state transitions explicit and protect the Entity from inconsistent
   internal states, as they happend by rebining <span class="emphasis"><em>one</em></span> variable, not several.
</li><li class="listitem">
Entity and EntityStates are easier to test.
</li></ol></div><p>However, unlike the classical State pattern, the EntityState objects provide
to the Entity its full state, thus it will have many instance field (at least
the identifier). As a conseguence two different entities can not share their
states.</p><p>Finally, in a multithread environment (like Epic.Server) serving requests from
different applications, both consistency and parallelism will be guaranteed from
the fine-grained locking provided from the Compare &amp; Swap instruction.
Many Entities will be able to handle commands in parallel, without any loss in
the readability of the code.</p></div><div class="section" title="Implementation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_implementation"></a>Implementation</h2></div></div></div><p>The Single Mutable State pattern is easy to implement but it’s quite verbose.
The main issue is to keep the Entity’s state field correctly updated and to
use the right state to handle each request.</p><p>Here you can see the algoritm used on a heavily simplified real world entity.</p><script type="syntaxhighlighter" class="brush: csharp">public class InvestmentProposal : IInvestmentProposal
{
    protected InvestmentProposalState CurrentState;

    public ProposalDate ProposalDate
    {
        get
        {
            return CurrentState.ProposalDate;
        }
    }

    // more events, queries and commands here...

    public void Acquire (FundQuote quote)
    {
        // Thread safe, lock free sincronization
        InvestmentProposalState stateBeforeTransition;
        InvestmentProposalState previousState = CurrentState;
        do
        {
            stateBeforeTransition = previousState;
            InvestmentProposalState newValue = stateBeforeTransition.Acquire(quote);
            previousState = Interlocked.CompareExchange&lt;InvestmentProposalState&gt;(ref this.CurrentState, newValue, stateBeforeTransition);
        }
        while (previousState != stateBeforeTransition);

        if(!previousState.Equals(this.CurrentState))
        {
            EventHandler&lt;EventArgs&gt; handler = AssetAcquired;
            if(null != handler)
                handler(this, args);
        }
    }

    public event EventHandler&lt;EventArgs&gt; AssetAcquired;
}</script></div><div class="section" title="Sample Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_sample_code"></a>Sample Code</h2></div></div></div><p>In the motivation section a real world example from previous financial
experience has been described. However the effort required to explain that
domain model would overwhelm the manual.</p><p>The Epic source code is provided with the classical Evans' example implemented
using the pattern described here. Look at the Cargo entity for a full example.</p></div><div class="section" title="Related Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_related_patterns"></a>Related Patterns</h2></div></div></div><p>The classical State pattern from the Gang of Four is the noble father of
the solution proposed here.</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id342916" href="#id342916" class="simpara">7</a>] </sup>Ok, I lied: pure interfaces for entities are required.
But they have so many advantages beyond Epic, that they should already exist,
even just to enable unit tests of the client code.</p></div><div class="footnote"><p><sup>[<a id="ftn.id342964" href="#id342964" class="simpara">8</a>] </sup>We want entities that can reside in their own
thread of control but that work equally well in a single threaded environment.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="repositories.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="the_bellis_perennis.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 7. Repositories </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Part II. The bellis perennis</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2011 Giacomo Tesio</div></div><script type="text/javascript">SyntaxHighlighter.all()</script></body></html>
