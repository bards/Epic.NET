<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="refresh" content="0;url=http://epic.tesio.it/doc/manual/command_query_separation.html" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 4. Command - Query separation</title><link rel="stylesheet" href="/layout.css" type="text/css" /><link rel="stylesheet" href="/screen.css" type="text/css" /><link rel="stylesheet" href="css/shCore.css" type="text/css" /><link rel="stylesheet" href="css/shCoreDefault.css" type="text/css" /><link rel="stylesheet" href="css/shThemeDefault.css" type="text/css" /><link rel="stylesheet" href="css/documentation.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="shared_identifiers.html" title="Chapter 3. Shared Identifiers" /><link rel="next" href="observable_entities.html" title="Chapter 5. Observable Entities" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><script src="script/shCore.js" type="text/javascript"></script><script src="script/shBrushCSharp.js" type="text/javascript"></script><link rel="alternate" type="application/atom+xml" title="Development log" href="atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </xsl:element>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--></head><body><div id="wrap"><div id="header"><a href="http://github.com/Shamar/Epic.NET/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><a class="title" href="/">Epic</a><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter" title="Chapter 4. Command - Query separation"><div class="titlepage"><div><div><h2 class="title"><a id="command_query_separation"></a>Chapter 4. Command - Query separation</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="command_query_separation.html#about_a_simple_convention">A simple convention</a></span></li><li><span class="section"><a href="command_query_separation.html#about_what_about_factory_methods">What about factory methods?</a></span></li><li><span class="section"><a href="command_query_separation.html#about_idempotence">Idempotence</a></span></li></ul></div><p>CQS is a well known principle in object oriented programming after Bertrand
Meyer. It state that we should divide an object’s methods into two sharply
separated categories:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<span class="strong"><strong>queries</strong></span> that return a result and do not change the observable state of the
  system (are free of side effects).
</li><li class="listitem">
<span class="strong"><strong>commands</strong></span> that change the state of a system but do not return a value.
</li></ul></div><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>As you might know by experience, side effects are expensive.
For example, for each new mutable flag in a class, the number of possible
states will double. When you model a domain, you should remember that
minimizing the side effects means minimizing complexity (thus <span class="strong"><strong>maximizing
the revenues</strong></span>).</p></td></tr></table></div><p>As for value objects, all their methods must be queries. They must be immutable
and no method of theirs should modify either the arguments or the system.</p><p>Domain services could be designed to change the system (by sending an email or
writing a report) and in such case you should make such change explicit.</p><p>Mutable entities could have both query methods and commands. You should cleanly
diffirenciate them, so that all model’s users will grasp the rationale of each
method.</p><div class="section" title="A simple convention"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_a_simple_convention"></a>A simple convention</h2></div></div></div><p>We adopted an idiomatic convention with the following rules:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
queries return a value;
</li><li class="listitem">
commands must be void;
</li><li class="listitem">
should a command returns a value, it will go through an <code class="literal">out</code> parameter that
  will have a meaningful name;
</li><li class="listitem">
properties are readonly (thus they are always query);
</li><li class="listitem">
entity’s queries should never throw exceptions (argument validation apart);
</li><li class="listitem">
commands must be well documented and thrown exceptions should be
  listed and explained already in the interfaces.
</li></ul></div><div class="caution" title="Caution" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Caution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Caution]" src="images/caution.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>This is probably the major concern in the choice of C# for modeling
tasks. Checked exceptions would be valuable for us! We want that clients breaks
as early as possible when we change the domain.</p></td></tr></table></div><p>We apply these rules without exception. Epic will provide a set of Gendarme’s
rules to check the adherence to such rules, but it will not force them by
default.</p></div><div class="section" title="What about factory methods?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_what_about_factory_methods"></a>What about factory methods?</h2></div></div></div><p>Factory methods are worth a dedicated section since it could be difficult to
ponder whether they are queries or commands.</p><p>We all know the creational pattern that encapsulates the creation of objects in
a method owned by another class (either static or not).</p><p>In the context of Epic, you should separate two kind of factory methods:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
those that build value objects (such as specifications, itineraries or
  moneys);
</li><li class="listitem">
those that build entities.
</li></ul></div><p>Providing a new instance of a value object does not change the system: you can
create all the copies of a <code class="literal">PreferredStockQuantity</code> you like, but until you do
not <code class="literal">Purchase(PreferredStockQuantity)</code> that quantity, your securities account
doesn’t change! <br />
Since such operation do not change the observable state of the system, it is a
query and should return a value.</p><p>Creating a new securities account, instead, deeply changes the system: first
the bank smiles, but what matter is that the identifier assigned to your
account is taken forever. No other account can take that identifier.<br />
This is definitely a command: it should be a void method and the new account
(or its identifier at least) should be returned in an <code class="literal">out</code> parameter.</p></div><div class="section" title="Idempotence"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_idempotence"></a>Idempotence</h2></div></div></div><p>Idempotence is another well known principle in math and functional programming.
It is the property of operations that can be applied multiple
times without changing the result.</p><p>C# does not handle referential transparency and since we design mutable
entities, idempotence can not be adopted as when we programm, say, in Haskell.
Nevertheless it profitable to prefer idempotent APIs.</p><p>Methods of both value objects and domain services should be designed to be
idempotent.
However, when they get an entity as an argument the result could change among
subsequent calls, as the entity recieves a command.</p><div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png" /></td><th align="left"></th></tr><tr><td align="left" valign="top"><p>Each instance of an entity holds a mutable state that affects the
result of depending queries.</p></td></tr></table></div><p>Entities' queries are a bit trickier: you should always get the same result
when calling with the same arguments, until either the method’s owner or the
arguments recieve a command.</p><p>Commands of entities are even more complex: you should design them to be
idempotent as far as possible. For example, you could prefer methods like
<code class="literal">SetSomething()</code> instead of <code class="literal">AddSomething()</code> and <code class="literal">RemoveSomething()</code>, thus
allowing idempotence (and reducing the interface size) without
affecting comprehensibility.</p><p>Indeed, it’s often quite easy to adopt idempotent APIs. See for example the
<code class="literal">IVoyage</code> interface in the DDDSample from the Epic source code: commands like
<code class="literal">StopOver(ILocation)</code> and <code class="literal">DepartFrom(ILocation)</code> are both idempotent and
expressive.<br />
If a voyage either departs from a location or stop over a location twice,
it will always be in the same state.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="shared_identifiers.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="observable_entities.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 3. Shared Identifiers </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Chapter 5. Observable Entities</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2011 Giacomo Tesio</div></div><script type="text/javascript">SyntaxHighlighter.all()</script></body></html>
