<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="refresh" content="0;url=http://epic.tesio.it/doc/manual/bounded_roles.html" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 2. Bounded Roles</title><link rel="stylesheet" href="/layout.css" type="text/css" /><link rel="stylesheet" href="/screen.css" type="text/css" /><link rel="stylesheet" href="css/shCore.css" type="text/css" /><link rel="stylesheet" href="css/shCoreDefault.css" type="text/css" /><link rel="stylesheet" href="css/shThemeDefault.css" type="text/css" /><link rel="stylesheet" href="css/documentation.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="manual.html" title="Dominant Domains" /><link rel="up" href="a_shared_modeling_grammar.html" title="Part I. Toward a shared modeling grammar" /><link rel="prev" href="poco.html" title="Chapter 1. Plain old CLR objects" /><link rel="next" href="shared_identifiers.html" title="Chapter 3. Shared Identifiers" /><meta charset="utf-8" /><link rel="icon" href="/favicon.ico" /><script src="script/shCore.js" type="text/javascript"></script><script src="script/shBrushCSharp.js" type="text/javascript"></script><link rel="alternate" type="application/atom+xml" title="Development log" href="atom.xml" /><!--[if !IE 7]>
    <style type="text/css">
		#wrap {display:table;height:100%}
	</style>
  <![endif]--><!--[if lt IE 8]>
    <style type="text/css">
        #header {padding-top: 9px}
    </xsl:element>
  <![endif]--><!--[if IE 8]>
    <style type="text/css">
		#wrap {width:100%}
	</style>
  <![endif]--></head><body><div id="wrap"><div id="header"><a href="http://github.com/Shamar/Epic.NET/"><img style="position: absolute; top: 0; left: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png" alt="Fork me on GitHub" /></a><a class="title" href="/">Epic</a><span>dominant domains</span></div><div id="main"><div id="content"><div class="chapter" title="Chapter 2. Bounded Roles"><div class="titlepage"><div><div><h2 class="title"><a id="bounded_roles"></a>Chapter 2. Bounded Roles</h2></div></div></div><div class="toc"><ul><li><a href="/doc/manual.html" class="toc-title">Table of Contents</a></li><li><span class="section"><a href="bounded_roles.html#about_know_your_users">Know your users</a></span></li><li><span class="section"><a href="bounded_roles.html#about_binding_roles_to_contexts">Binding roles to contexts</a></span></li><li><span class="section"><a href="bounded_roles.html#about_complexity_partition">Complexity partition</a></span></li><li><span class="section"><a href="bounded_roles.html#about_a_junction_point">A junction point</a></span></li></ul></div><p>Whenever you have to deal with a large project, you’ll have to
define a set of bounded contexts, each describing a different <span class="strong"><strong>point of view</strong></span>
upon the same concepts.</p><p>What is an entity in a context will be a value object in another.</p><p>When related to enterprise processes, such contexts will be connected to the
organization chart: different users can access to different contexts, often
with slightly different capabilities.</p><p>Moreover, while you can sell the same domain model to different organizations,
you can’t neither predict nor generalize the organizational structure.
<sup>[<a id="id294361" href="#ftn.id294361" class="footnote">2</a>]</sup>
You can make your software configurable, but whenever the access control
rules are complex enough you fall in a customization hell that will erode
the return on investment.</p><p>As an alternative, we decided to model the typical roles of the customer’s
organization, each providing the entry-point to a bounded context.</p><p>This was hard to explain to our stakeholders, since for each new customer
we get, there are a set of modeling tasks to do.
However, as these activities can be easily planned, they managed to value them
as a really cool feature: we can customize the applications we sell to fit the
corporate structure of the customer!</p><div class="section" title="Know your users"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_know_your_users"></a>Know your users</h2></div></div></div><p>All applications have users. This is so evident that it’s often forgot.</p><p>Each day a user log into our application and access a set of functionalities.
He can browse statistical reports and portfolios, he fills profiles of his own
customers, he advises them, he plans gifts for them, he sends their orders to
financial markets and so on.
But he can also access reports about his colleagues, aggregate statistics about
their performances. Some time he can send to them alerts. He can even build a
report forecasting the enterprise’s revenues for the board of directors.</p><p>What he can do depend on the position he plays in the organization.
And you know how complex could be an human organization.
At first it seem a simple hierarchy, a tree of roles, but soon you learn
that assistants must be able to operate for their boss, that private bankers
are not born equals and that exceptions exists… just to make you crazy.</p><p>If you ever thought to model each kind of user, you know what I mean.</p><p>Nevertheless you need to know what each user can do, when and how.
Delegating such logic to the infrastructure is just an illusion: you are
moving the problem elsewhere (often where it’s harder to solve non-trivial
cases).</p></div><div class="section" title="Binding roles to contexts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_binding_roles_to_contexts"></a>Binding roles to contexts</h2></div></div></div><p>The solution we found is to model the roles of customer’s organization after
the domain contexts.</p><p>Each role provides access to a set of repositories, domain services,
responsibility and tools just like any real role in any real enterprise.
We found that roles follow almost exactly the context boundaries of our best
domains, sometimes customized with addictional requirements.</p><p>We were not afraid to write specific code for each customer, confident that a
satisfied customer would have paid more.</p></div><div class="section" title="Complexity partition"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_complexity_partition"></a>Complexity partition</h2></div></div></div><p>Bounded contexts are among the most undervalued tools in software development.
They are useful beyond the niche of domain-driven development.</p><p>As you know, when an application grows, its own complexity increases.<br />
Developers try to avoid spaghetti-code, by applying a set of smart design
patterns that should allow for easier evolution.
However, the "overdesign" hell is just around the corner.
What if your software evolves on unexpected axes?</p><p>As a simple alternative, you could adopt well-defined and documented
boundaries, that describe small contexts: such boundaries should be first
class citizens in the ubiquitous language.</p><p>Everyone knows that different roles can access to the same things but with
different responsibilities: the <code class="literal">IPatient</code> that a <code class="literal">IPlasticSurgeon</code> operates
have the same <code class="literal">InsuranceCode</code> of the <code class="literal">IPatient</code> treated by the <code class="literal">ICardiologist</code>,
but they are different for everything else.</p><p>Splitting the applications into bounded contexts, each linked to a user role,
allow to model a simpler reality. You will have two classes named <code class="literal">IPatient</code> in
different namespaces but each class will be designed according to a specific
point of view, to satisfy a smaller set of requirements.</p></div><div class="section" title="A junction point"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="about_a_junction_point"></a>A junction point</h2></div></div></div><p>Roles have proved to be an efficent junction point between the pure domain
model (implemented as plain old CLR objects) and the hosting infrastructure.</p><p>Logging, persistence, resource allocations, user locking and so on:
all passes through the users' roles that act as a natural injector for the
infrastructural code.</p><p>For example the repositories can bind the user’s access to specified entities,
according to the fanciest rules that your customer can imagine, the domain
services can be customized to log calls or to cache results and everything you
hate will become easy.</p><p>You just have to deal with angry stakeholders that will tell you: "but we
already did it three months ago!"</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id294361" href="#id294361" class="simpara">2</a>] </sup>In the second chapter of Analysis Pattern, Martin Fowler describe a
set of patterns for accountability management. While such patterns are both
elegant and powerfull we found them affected by a major flaw: they are not
part of the ubiquitous language.<br />
We prefer to learn the language from domain experts instead of teaching them
our own.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="poco.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="a_shared_modeling_grammar.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="shared_identifiers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 1. Plain old CLR objects </td><td width="20%" align="center"><a accesskey="h" href="manual.html">Table of Contents</a></td><td width="40%" align="right" valign="top"> Chapter 3. Shared Identifiers</td></tr></table></div></div></div></div><div id="footer"><div class="copyright">Copyright © 2010-2011 Giacomo Tesio</div></div><script type="text/javascript">SyntaxHighlighter.all()</script></body></html>
